#![feature(asm)]

macro_rules! const_bop_def {
    ($($tr:ident $m:ident),*) => (
        $(
            pub trait $tr {
                fn $m(self, other: Self) -> Self;
            }
        )*
    )
}
const_bop_def! {
    ConstAdd const_add,
    ConstSub const_sub,
    ConstMul const_mul,
    ConstDiv const_div,
    ConstRem const_rem,
    ConstBiAnd const_and,
    ConstOr const_or,
    ConstBitXor const_bit_xor,
    ConstBitAnd const_bit_and,
    ConstBitOr const_bit_or
}

macro_rules! const_bop_cmp_def {
    ($($tr:ident $m:ident),*) => (
        $(
            pub trait $tr {
                fn $m(self, other: Self) -> bool;
            }
        )*
    )
}
const_bop_cmp_def! {
    ConstEq const_eq,
    ConstLt const_lt,
    ConstLe const_le,
    ConstNe const_ne,
    ConstGe const_ge,
    ConstGt const_gt
}

pub trait ConstShl {
    fn const_shl(self, b: usize) -> Self;
}
pub trait ConstShr {
    fn const_shr(self, b: usize) -> Self;
}

macro_rules! const_uop_def {
    ($($tr:ident $m:ident),*) => (
        $(
            pub trait $tr {
                fn $m(self) -> Self;
            }
        )*
    )
}
const_uop_def! {
    ConstNeg const_neg,
    ConstNot const_not
}

pub trait ConstIf<T> {
    fn const_if(self, if_expr: T, else_expr: T) -> T;
}

// amd64 implementation

macro_rules! const_bop {
    (
        $tr:ident,
        $m:ident,
        $asm:expr,
        $($t:ty),*
    ) => (
        $(
            impl $tr for $t {
                #[inline(always)]
                #[allow(unused_mut)]
                fn $m(self, b: $t) -> $t {
                    let mut ret: $t;
                    unsafe {
                        asm!($asm : "=r"(ret) : "r"(b), "0"(self) : "cc");
                    }
                    ret
                }
            }
        )*
    )
}

const_bop! {
    ConstAdd, const_add,
    "add $1, $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}

const_bop! {
    ConstSub, const_sub,
    "sub $1, $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}

const_bop! {
    ConstBitXor, const_bit_xor,
    "xor $1, $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}

const_bop! {
    ConstBitAnd, const_bit_and,
    "and $1, $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}

const_bop! {
    ConstBitOr, const_bit_or,
    "or $1, $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}

const_bop! {
    ConstMul, const_mul,
    "imul $1, $0",
    u16, u32, u64, usize, i16, i32, i64, isize
}

// u8/i8 is exceptional
macro_rules! const_mul8 {
    ($($t:ty)*) => (
        $(
            impl ConstMul for $t {
                #[inline(always)]
                #[allow(unused_mut)]
                fn const_mul(self, b: $t) -> $t {
                    let mut ret: $t;
                    unsafe {
                        asm!("mulb $1" : "={al}"(ret) : "r"(self), "{al}"(b) : "cc", "ax");
                    }
                    ret
                }
            }
        )*
    )
}
const_mul8! {u8 i8}

// shl/shr
macro_rules! const_shift {
    (
        $tr:ident,
        $m:ident,
        $asm:expr,
        $($t:ty),*
    ) => (
        $(
            impl $tr for $t {
                #[inline(always)]
                #[allow(unused_mut)]
                fn $m(self, b: usize) -> $t {
                    let mut ret: $t;
                    unsafe {
                        // FIXME: overlong shift is undefined in Rust (rust-lang/rust#10183)
                        asm!($asm : "=r"(ret) : "{cl}"(b as u8), "0"(self) : "cc");
                    }
                    ret
                }
            }
        )*
    )
}

const_shift! {
    ConstShl, const_shl,
    "shl $1, $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}
const_shift! {
    ConstShr, const_shr,
    "shr $1, $0",
    u8, u16, u32, u64, usize
}
const_shift! {
    ConstShr, const_shr,
    "sar $1, $0",
    i8, i16, i32, i64, isize
}

macro_rules! const_cmp {
    (
        $tr:ident,
        $m:ident,
        $asm:expr,
        $($t:ty),*
    ) => (
        $(
            impl $tr for $t {
                #[inline(always)]
                #[allow(unused_mut)]
                fn $m(self, b: $t) -> bool {
                    let mut ret: bool;
                    unsafe {
                        asm!($asm : "=r"(ret) : "r"(b), "r"(self) : "cc");
                    }
                    ret
                }
            }
        )*
    )
}

const_cmp! {
    ConstEq, const_eq,
    "cmp $1, $2; sete $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}

const_cmp! {
    ConstLt, const_lt,
    "cmp $1, $2; setb $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}
const_cmp! {
    ConstGt, const_gt,
    "cmp $2, $1; setb $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}
const_cmp! {
    ConstLe, const_le,
    "cmp $1, $2; setbe $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}
const_cmp! {
    ConstGe, const_ge,
    "cmp $2, $1; setbe $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}

macro_rules! const_uop {
    (
        $tr:ident,
        $m:ident,
        $asm:expr,
        $($t:ty),*
    ) => (
        $(
            impl $tr for $t {
                #[inline(always)]
                #[allow(unused_mut)]
                fn $m(self) -> $t {
                    let mut ret: $t;
                    unsafe {
                        asm!($asm : "=r"(ret) : "0"(self) : "cc");
                    }
                    ret
                }
            }
        )*
    )
}

const_uop! {
    ConstNeg, const_neg,
    "neg $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}
const_uop! {
    ConstNot, const_not,
    "not $0",
    u8, u16, u32, u64, usize, i8, i16, i32, i64, isize
}

macro_rules! const_if {
    ($($t:ty),*) => (
        $(
            impl ConstIf<$t> for bool {
                fn const_if(self, a: $t, b: $t) -> $t {
                    // switch = if cond { 0 } else { 0b111...111 }
                    let switch = (self as $t).const_sub(1);

                    let axb = a.const_bit_xor(b);
                    // mask = if cond { 0 } else { a ^ b }
                    let mask = axb.const_bit_and(switch);
                    // ret = if cond { a } else { b }
                    let ret = mask.const_bit_xor(a);

                    ret
                }
            }
        )*
    )
}

const_if! {u8, u16, u32, u64, usize, i8, i16, i32, i64, isize}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_const_if() {
        for a in 0u8 .. 255 {
            for b in 0u8 .. 255 {
                let must_be_a = true.const_if(a, b);
                let must_be_b = false.const_if(a, b);

                assert_eq!(must_be_a, a);
                assert_eq!(must_be_b, b);
            }
        }
    }
}


#![feature(concat_idents)]
#![feature(plugin)]

#![plugin(regex_macros)]

#[cfg(feature = "postgres")]
extern crate postgres;
#[cfg(feature = "postgres")]
extern crate r2d2;
#[cfg(feature = "postgres")]
extern crate r2d2_postgres;
extern crate time;

extern crate regex;
extern crate deuterium;
extern crate byteorder;
extern crate num;

#[cfg(feature = "postgres")]
pub use adapter::postgres::*;

#[macro_use] pub mod adapter;
#[macro_use] pub mod migration;


use regex::{Regex};
use std::str::{FromStr};

use super::super::metrics::*;

/// Reader that takes a log line string and returns any metrics found in it.
pub trait LogLineReader: Send + Sync {
    fn read(&self, &str) -> Vec<Metric>;
}

/// Reads metrics from log lines in the standard formats:
///
/// - Measures: `measure#metric=1.2`
/// - Counts: `count#metric=3`
pub struct StandardLogLineReader;

lazy_static! {
    static ref LOG_MEASURE_REGEX: Regex =
        Regex::new(r"measure#([[:alnum:]._]+)=(\d+(?:\.\d+)?)").unwrap();

    static ref LOG_SAMPLE_REGEX: Regex =
        Regex::new(r"sample#([[:alnum:]._]+)=(\d+(?:\.\d+)?)").unwrap();

    static ref LOG_COUNT_REGEX: Regex =
        Regex::new(r"count#([[:alnum:]._]+)=(\d+)").unwrap();

    static ref SOURCE_REGEX: Regex =
        Regex::new(r"source=([[:alnum:]._]+)").unwrap();
}

impl StandardLogLineReader {
    fn parse_source<'a>(line: &'a str) -> Option<&'a str> {
        SOURCE_REGEX.captures(line)
                    .and_then(|c| c.get(1))
                    .map(|m| m.as_str())
    }
}

impl LogLineReader for StandardLogLineReader {
    fn read(&self, line: &str) -> Vec<Metric> {
        let source = StandardLogLineReader::parse_source(line).map(|s| s.to_owned());
        let dimension = |name: &str| {
            Dimension { name: name.to_owned(), source: source.clone() }
        };

        let mut metrics = vec![];

        // Look for counts
        for cap in LOG_COUNT_REGEX.captures_iter(line) {
            let name = cap.get(1).unwrap().as_str();

            if let Ok(value) = u64::from_str(cap.get(2).unwrap().as_str()) {
                metrics.push(Count(dimension(name), value))
            }
        }

        // Look for measures
        for cap in LOG_MEASURE_REGEX.captures_iter(line) {
            let name = cap.get(1).unwrap().as_str();

            if let Ok(value) = f64::from_str(cap.get(2).unwrap().as_str()) {
                metrics.push(Measure(dimension(name), value))
            }
        }

        // Look for samples
        for cap in LOG_SAMPLE_REGEX.captures_iter(line) {
            let name = cap.get(1).unwrap().as_str();

            if let Ok(value) = f64::from_str(cap.get(2).unwrap().as_str()) {
                metrics.push(Sample(dimension(name), value))
            }
        }

        metrics
    } // fn read
}

/// Reads Heroku's logging metrics.
pub struct HerokuLogLineReader;

lazy_static! {
    static ref DYNO_TYPE_REGEX: Regex =
        Regex::new(r"dyno=([[:alpha:]]+)").unwrap();

    static ref CONNECT_REGEX: Regex =
        Regex::new(r"connect=(\d+)ms").unwrap();

    static ref SERVICE_REGEX: Regex =
        Regex::new(r"service=(\d+)ms").unwrap();

    static ref STATUS_REGEX: Regex =
        Regex::new(r"status=(\d+)").unwrap();

    static ref HEROKU_HTTP_ERROR_CODE_REGEX: Regex =
        Regex::new(r"code=(H\d+)").unwrap();

    static ref HEROKU_RUNTIME_ERROR_CODE_REGEX: Regex =
        Regex::new(r"Error (R\d+)").unwrap();

    static ref LOAD_AVG_1M_REGEX: Regex =
        Regex::new(r"sample#load_avg_1m=([0-9.]+)").unwrap();
}

impl HerokuLogLineReader {
    /// Parses Heroku router status lines for the response service time (how
    /// long it took) and the HTTP response status.
    pub fn parse_status(line: &str) -> Option<Vec<Metric>> {
        let mut metrics: Vec<Metric> = vec![];

        let connect = match CONNECT_REGEX.captures(line)
            .and_then(|c| c.get(1))
            .map(|m| m.as_str())
            .and_then(|c| u16::from_str(c).ok()) {
                Some(c) => c,
                None => return None,
            };

        let status = match STATUS_REGEX.captures(line)
            .and_then(|c| c.get(1))
            .map(|m| m.as_str())
            .and_then(|s| u16::from_str(s).ok()) {
                Some(s) => s,
                None => return None,
            };

        let service = match SERVICE_REGEX.captures(line)
            .and_then(|c| c.get(1))
            .map(|m| m.as_str())
            .and_then(|s| u32::from_str(s).ok()) {
                Some(s) => s,
                None => return None,
            };

        let dyno_type = match DYNO_TYPE_REGEX.captures(line)
            .and_then(|c| c.get(1))
            .map(|m| m.as_str()) {
                Some(d) => d,
                None => return None,
            };

        let base = format!("dyno.{}", dyno_type);

        // Counting a 499 as a 500
        let is_500 = status >= 499 && status < 600;

        // Don't record timing for 499 and 5xx errors
        if !is_500 {
            let service_time_name = format!("{}.service_time", base);
            metrics.push(Measure(Dimension::with_name_and_source(service_time_name, dyno_type), service as f64));
        }

        // Track the connect time (how long it took to pick up the request)
        let connect_time_name = format!("{}.connect_time", base);
        metrics.push(Measure(Dimension::with_name_and_source(connect_time_name, dyno_type), connect as f64));

        // Count the status
        let status_name = format!("{}.status.{}", base, status);
        metrics.push(Count(Dimension::with_name_and_source(status_name, dyno_type), 1));

        Some(metrics)
    }

    /// Parses Heroku warning and error codes like "Hxx" and "Rxx" where "xx" is a pair
    /// of numbers. See the [Heroku][] site for more details.
    ///
    /// [Heroku]: https://devcenter.heroku.com/articles/error-codes
    pub fn parse_heroku_code(line: &str) -> Option<Metric> {
        let code: &str;

        if let Some(http_code) = HEROKU_HTTP_ERROR_CODE_REGEX.captures(line).and_then(|c| c.get(1)).map(|m| m.as_str()) {
            code = http_code;

        } else if let Some(runtime_code) = HEROKU_RUNTIME_ERROR_CODE_REGEX.captures(line).and_then(|c| c.get(1)).map(|m| m.as_str()) {
            code = runtime_code;

        } else {
            return None
        }

        let name = format!("heroku.error.{}", code);
        Some(Count(Dimension::with_name(name), 1))
    }

    /// Parses the `sample#load_avg_1m=` metrics from Heroku logs.
    pub fn parse_load(line: &str) -> Option<Metric> {
        let load_avg_1m = match LOAD_AVG_1M_REGEX.captures(line)
                                                 .and_then(|c| c.get(1))
                                                 .map(|m| m.as_str())
                                                 .and_then(|c| f64::from_str(c).ok()) {
            Some(l) => l,
            None => return None,
        };

        let source = match StandardLogLineReader::parse_source(line) {
            Some(s) => s,
            None => return None,
        };

        let dyno_type = match source.split('.').nth(0) {
            Some(s) => s,
            None => return None,
        };

        let dim = Dimension::with_name_and_source(format!("dyno.{}.load_avg_1m", dyno_type), source);
        Some(Measure(dim, load_avg_1m))
    }
}

impl LogLineReader for HerokuLogLineReader {
    fn read(&self, line: &str) -> Vec<Metric> {
        if !line.contains("heroku") { return vec![] }

        let mut metrics: Vec<Metric> = vec![];

        if let Some(statuses) = HerokuLogLineReader::parse_status(line)      { metrics.extend(statuses) }
        if let Some(code)     = HerokuLogLineReader::parse_heroku_code(line) { metrics.push(code) }
        if let Some(load)     = HerokuLogLineReader::parse_load(line)        { metrics.push(load) }

        metrics
    }
}

#[cfg(test)]
mod tests {
    use super::{
        LogLineReader,
        StandardLogLineReader,
        HerokuLogLineReader
    };
    use super::super::super::metrics::*;

    #[test]
    fn standard_reader_reads_measure() {
        let reader = StandardLogLineReader;
        let line = "measure#foo=1.2\n";

        assert_eq!(
            reader.read(line),
            vec![ Measure(Dimension::with_name("foo"), 1.2) ]
        )
    }

    #[test]
    fn standard_reader_reads_measure_with_source() {
        let reader = StandardLogLineReader;
        let line = "source=web measure#foo=1.2\n";

        assert_eq!(
            reader.read(line),
            vec![ Measure(Dimension::with_name_and_source("foo", "web"), 1.2) ]
        )
    }

    #[test]
    fn standard_reader_reads_count() {
        let reader = StandardLogLineReader;
        let line = "count#foo=1\n";

        assert_eq!(
            reader.read(line),
            vec![ Count(Dimension::with_name("foo"), 1) ]
        )
    }

    #[test]
    fn standard_reader_reads_sample() {
        let reader = StandardLogLineReader;
        let line = "sample#bar=3.4\n";

        assert_eq!(
            reader.read(line),
            vec![ Sample(Dimension::with_name("bar"), 3.4) ]
        )
    }

    #[test]
    fn standard_reader_returns_nothing_on_failed_read() {
        let reader = StandardLogLineReader;
        let line = "metric#bar=3.4\n";

        assert_eq!(
            reader.read(line),
            vec![]
        )
    }

    #[test]
    fn standard_reader_parses_source() {
        let line = "source=something metric#other=5.6\n";

        assert_eq!(
            StandardLogLineReader::parse_source(line),
            Some("something")
        )
    }

    #[test]
    fn heroku_reader_reads_loads() {
        let reader = HerokuLogLineReader;
        let line = "2016-02-26 21:34:59.429615+00:00 heroku web.2 - - source=web.2 dyno=heroku.123.XYZ sample#load_avg_1m=0.56 sample#load_avg_5m=0.26 sample#load_avg_15m=0.17\n";

        assert_eq!(
            reader.read(line),
            vec![ Measure(Dimension::with_name_and_source("dyno.web.load_avg_1m", "web.2"), 0.56) ]
        )
    }

    #[test]
    fn heroku_reader_reads_http_errors() {
        let reader = HerokuLogLineReader;
        let line = "2016-02-26 21:50:36.352129+00:00 heroku router - - sock=backend at=error code=H18 desc=\"Server Request Interrupted\" method=GET path=\"/\" host=www.example.com request_id=XYZ fwd=\"1.2.3.4\" dyno=web.5 connect=0ms service=495ms status=503 bytes=1648\n";

        assert_eq!(
            reader.read(line),
            vec![
                Measure(Dimension::with_name_and_source("dyno.web.connect_time", "web"), 0.0),
                Count(Dimension::with_name_and_source("dyno.web.status.503", "web"), 1),
                Count(Dimension::with_name("heroku.error.H18"), 1),
            ]
        )
    }

    #[test]
    fn heroku_reader_reads_runtime_errors() {
        let reader = HerokuLogLineReader;
        let line = "2016-02-25 21:35:34.990292+00:00 heroku scheduler.5451 - - Error R14 (Memory quota exceeded)\n";

        assert_eq!(
            reader.read(line),
            vec![
                Count(Dimension::with_name("heroku.error.R14"), 1),
            ]
        )
    }

    #[test]
    fn heroku_reader_reads_service_times() {
        let reader = HerokuLogLineReader;
        let line = "2016-02-26 21:34:59.370813+00:00 heroku router - - at=info method=PUT path=\"/\" host=www.example.com request_id=XYZ fwd=\"1.2.3.4\" dyno=web.1 connect=1ms service=39ms status=200 bytes=1627\n";

        assert_eq!(
            reader.read(line),
            vec![
                Measure(Dimension::with_name_and_source("dyno.web.service_time", "web"), 39.0),
                Measure(Dimension::with_name_and_source("dyno.web.connect_time", "web"), 1.0),
                Count(Dimension::with_name_and_source("dyno.web.status.200", "web"), 1),
            ]
        )
    }
}

//! Functions and methods that return functions that are able to parse strings.
//!
//! These can be divided into parsers that return chars, strings, and generic Ts.
// TODO: probably should use individual modules for these, but the dependencies
// are painful (see https://github.com/mozilla/rust/issues/3352).
use core::str::CharRange;

use misc::*;
use types::*;

/// Return type of parse function.
pub type ParseStatus<T: Copy Durable> = result::Result<T, ParseFailed>;

/// Returned by parse function on error. Line and col are both 1-based.
pub struct ParseFailed {file: @~str, line: uint, col: uint, mesg: @~str}

// ---- weird parsers -----------------------------------------------------------------------------
// Returns a parser which matches the end of the input.
// Clients should use everything instead of this.
#[doc(hidden)]
pub fn eot() -> Parser<()>
{
	|input: State|
	{
		if input.text[input.index] == EOT
		{
			result::Ok(Succeeded {new_state: State {index: input.index + 1u, ..input}, value: ()})
		}
		else
		{
			result::Err(Failed {old_state: input, err_state: input, mesg: @~"EOT"})
		}
	}
}

// ---- char parsers ------------------------------------------------------------------------------
/// Consumes a character which must satisfy the predicate.
/// Returns the matched character.
pub fn anycp(predicate: fn@ (char) -> bool) -> Parser<char>
{
	|input: State| {
		let mut i = input.index;
		if input.text[i] != EOT && predicate(input.text[i])
		{
			i += 1u;
		}
		
		if i > input.index
		{
			result::Ok(Succeeded {new_state: State {index: i, ..input}, value: input.text[input.index]})
		}
		else
		{
			result::Err(Failed {old_state: input, err_state: State {index: i, ..input}, mesg: @~""})
		}
	}
}

/// Parse methods which return a character.
pub trait CharParsers
{
	/// Attempts to match any character in self. If matched the char is returned.
	fn anyc(&self) -> Parser<char>;
	
	/// Attempts to match no character in self. If matched the char is returned.
	fn noc(&self) -> Parser<char>;
}

pub impl &str : CharParsers
{
	fn anyc(&self) -> Parser<char>
	{
		// Note that we're handing this string off to a closure so we can't get rid of this copy
		// even if we make the impl on ~str.
		let s = self.to_owned();
		
		|input: State|
		{
			let mut i = input.index;
			if str::find_char(s, input.text[i]).is_some()
			{
				i += 1u;
			}
			
			if i > input.index
			{
				result::Ok(Succeeded {new_state: State {index: i, ..input}, value: input.text[input.index]})
			}
			else
			{
				result::Err(Failed {old_state: input, err_state: State {index: i, ..input}, mesg: @fmt!("[%s]", s)})
			}
		}
	}
	
	fn noc(&self) -> Parser<char>
	{
		let s = self.to_owned();
		
		|input: State|
		{
			let mut i = input.index;
			if input.text[i] != EOT && str::find_char(s, input.text[i]).is_none()
			{
				i += 1u;
			}
			
			if i > input.index
			{
				result::Ok(Succeeded {new_state: State {index: i, ..input}, value: input.text[input.index]})
			}
			else
			{
				result::Err(Failed {old_state: input, err_state: State {index: i, ..input}, mesg: @fmt!("[^%s]", s)})
			}
		}
	}
}

// ---- string parsers ----------------------------------------------------------------------------
// It would be a lot more elegant if match0, match1, and co were removed
// and users relied on composition to build the sort of parsers that they
// want. However in practice this is not such a good idea:
// 1) Matching is a very common operation, but instead of something simple
// like:
//    match0(p)
// users would have to write something like:
//    match(p).r0().str()
// 2) Generating an array of characters and then converting them into a string
// is much slower than updating a mutable string.
// 3) Debugging a parser is simpler if users can use higher level building
// blocks (TODO: though maybe we can somehow ignore or collapse low
// level parsers when logging).

/// Consumes zero or more characters matching the predicate.
/// Returns the matched characters. 
/// 
/// Note that this does not increment line.
pub fn match0(predicate: fn@ (char) -> bool) -> Parser<@~str>
{
	|input: State|
	{
		let mut i = input.index;
		while input.text[i] != EOT && predicate(input.text[i])
		{
			i += 1u;
		}
		
		let text = str::from_chars(vec::slice(input.text, input.index, i));
		result::Ok(Succeeded {new_state: State {index: i, ..input}, value: @text})
	}
}

/// Consumes one or more characters matching the predicate.
/// Returns the matched characters. 
/// 
/// Note that this does not increment line.
pub fn match1(predicate: fn@ (char) -> bool) -> Parser<@~str>
{
	|input: State|
	{
		let mut i = input.index;
		while input.text[i] != EOT && predicate(input.text[i])
		{
			i += 1u;
		}
		
		if i > input.index
		{
			let text = str::from_chars(vec::slice(input.text, input.index, i));
			result::Ok(Succeeded {new_state: State {index: i, ..input}, value: @text})
		}
		else
		{
			result::Err(Failed {old_state: input, err_state: State {index: i, ..input}, mesg: @~""})
		}
	}
}

/// match1_0 := prefix+ suffix*
pub fn match1_0(prefix: fn@ (char) -> bool, suffix: fn@ (char) -> bool) -> Parser<@~str>
{
	let prefix = match1(prefix);
	let suffix = match0(suffix);
	prefix.thene(|p| suffix.thene(|s| ret(@(*p + *s))))
}

/// optional_str := e?
///
/// Returns an empty string on failure.
pub fn optional_str(parser: Parser<@~str>) -> Parser<@~str>
{
	|input: State|
	{
		match parser(input)
		{
			result::Ok(ref pass)		=> result::Ok(Succeeded {new_state: pass.new_state, value: pass.value}),
			result::Err(ref _failure)		=> result::Ok(Succeeded {new_state: input, value: @~""}),
		}
	}
}

/// Calls fun once and matches the number of characters returned by fun. 
/// 
/// This does increment line.  Note that this succeeds even if zero characters are matched.
///
/// # Fun's are typically written like this:
///
/// ~~~
/// fn to_new_line(chars: @[char], index: uint) -> uint
/// {
///     let mut i = index;
///     loop
///     {
///         // Chars will always have an EOT character. If we hit it then
///         // we failed to find a new-line character so match nothing. 
///         if chars[i] == EOT
///         {
///             return 0;
///         }
///         else if chars[i] == '\r' || chars[i] == '\n'
///         {
///             // Match all the characters up to, but not including, the first new line.
///             return i - index;
///         }
///         else
///         {
///             i += 1;
///         }
///     }
/// }
/// ~~~
pub fn scan(fun: fn@ (@[char], uint) -> uint) -> Parser<@~str>
{
	|input: State|
	{
		let mut i = input.index;
		let mut line = input.line;
		
		let count = fun(input.text, i);
		if count > 0u && input.text[i] != EOT		// EOT check makes it easier to write funs that do stuff like matching chars that are not something
		{
			for uint::range(0u, count)
			|_k| {
				if input.text[i] == '\r'
				{
					line += 1;
				}
				else if input.text[i] == '\n' && (i == 0u || input.text[i-1u] != '\r')
				{
					line += 1;
				}
				i += 1u;
			}
			let text = str::from_chars(vec::slice(input.text, input.index, i));
			result::Ok(Succeeded {new_state: State {index: i, line: line, ..input}, value: @text})
		}
		else
		{
			result::Ok(Succeeded {new_state: State {index: i, line: line, ..input}, value: @~""})
		}
	}
}


/// If all the parsers are successful then the matched text is returned.
pub fn seq2_ret_str<T0: Copy Durable, T1: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>) -> Parser<@~str>
{
	|input: State|
	{
		match p0.then(p1)(input)
		{
			result::Ok(ref pass) =>
			{
				let text = str::from_chars(vec::slice(input.text, input.index, pass.new_state.index));
				result::Ok(Succeeded {new_state: pass.new_state, value: @text})
			}
			result::Err(ref failure) =>
			{
				result::Err(Failed {old_state: input, ..*failure})
			}
		}
	}
}

/// If all the parsers are successful then the matched text is returned.
pub fn seq3_ret_str<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>) -> Parser<@~str>
{
	|input: State|
	{
		match p0.then(p1). then(p2)(input)
		{
			result::Ok(ref pass) =>
			{
				let text = str::from_chars(vec::slice(input.text, input.index, pass.new_state.index));
				result::Ok(Succeeded {new_state: pass.new_state, value: @text})
			}
			result::Err(ref failure) =>
			{
				result::Err(Failed {old_state: input, ..*failure})
			}
		}
	}
}

/// If all the parsers are successful then the matched text is returned.
pub fn seq4_ret_str<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>, p3: Parser<T3>) -> Parser<@~str>
{
	|input: State| {
		match p0.then(p1). then(p2).then(p3)(input)
		{
			result::Ok(ref pass) =>
			{
				let text = str::from_chars(vec::slice(input.text, input.index, pass.new_state.index));
				result::Ok(Succeeded {new_state: pass.new_state, value: @text})
			}
			result::Err(ref failure) =>
			{
				result::Err(Failed {old_state: input, ..*failure})
			}
		}
	}
}

/// If all the parsers are successful then the matched text is returned.
pub fn seq5_ret_str<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable, T4: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>, p3: Parser<T3>, p4: Parser<T4>) -> Parser<@~str>
{
	|input: State| {
		match p0.then(p1). then(p2).then(p3).then(p4)(input)
		{
			result::Ok(ref pass) =>
			{
				let text = str::from_chars(vec::slice(input.text, input.index, pass.new_state.index));
				result::Ok(Succeeded {new_state: pass.new_state, value: @text})
			}
			result::Err(ref failure) =>
			{
				result::Err(Failed {old_state: input, ..*failure})
			}
		}
	}
}

/// Parse methods which return a string.
pub trait StringParsers
{
	/// Returns the input that matches self. Also see liti and litv.
	fn lit(&self) -> Parser<@~str>;
	
	/// Returns the input that matches lower-cased self. Also see lit and litv.
	fn liti(&self) -> Parser<@~str>;
	
	/// s0 := e [ \t\r\n]*
	fn s0(&self) -> Parser<@~str>;
	
	/// s1 := e [ \t\r\n]+
	fn s1(&self) -> Parser<@~str>;
}

pub impl &str : StringParsers
{
	fn lit(&self) -> Parser<@~str>
	{
		let s = self.to_owned();
		
		|input: State|
		{
			let mut i = 0u;
			let mut j = input.index;
			while i < str::len(s)
			{
				let CharRange {ch, next} = str::char_range_at(s, i);
				if ch == input.text[j]
				{
					i = next;
					j += 1u;
				}
				else
				{
					break;
				}
			}
			
			if i == str::len(s)
			{
				let text = str::from_chars(vec::slice(input.text, input.index, j));
				result::Ok(Succeeded {new_state: State {index: j, ..input}, value: @text})
			}
			else
			{
				result::Err(Failed {old_state: input, err_state: State {index: j, ..input}, mesg: @fmt!("'%s'", s)})
			}
		}
	}
	
	fn liti(&self) -> Parser<@~str>
	{
		let s = str::to_lower(self);
		
		|input: State|
		{
			let mut i = 0u;
			let mut j = input.index;
			while i < str::len(s)
			{
				let CharRange {ch, next} = str::char_range_at(s, i);
				if ch == lower_char(input.text[j])
				{
					i = next;
					j += 1u;
				}
				else
				{
					break;
				}
			}
			
			if i == str::len(s)
			{
				let text = str::from_chars(vec::slice(input.text, input.index, j));
				result::Ok(Succeeded {new_state: State {index: j, ..input}, value: @text})
			}
			else
			{
				result::Err(Failed {old_state: input, err_state: State {index: j, ..input}, mesg: @fmt!("'%s'", s)})
			}
		}
	}
	
	fn s0(&self) -> Parser<@~str>
	{
		self.lit().s0()
	}
	
	fn s1(&self) -> Parser<@~str>
	{
		self.lit().s1()
	}
}

// ---- generic parsers ---------------------------------------------------------------------------
/// Returns a parser which always fails.
pub fn fails<T: Copy Durable>(mesg: &str) -> Parser<T>
{
	let mesg = mesg.to_owned();
	|input: State| result::Err(Failed {old_state: input, err_state: input, mesg: @copy mesg})
}

/// Parses with the aid of a pointer to a parser (useful for things like parenthesized expressions).
///
/// # Usage is like this:
///
/// ~~~
/// // create a pointer that we can initialize later with the real expr parser
/// let expr_ptr = @mut ret(0i);
/// let expr_ref = forward_ref(expr_ptr);
/// 
/// // expr_ref can be used to parse expressions
/// 
/// // initialize the expr_ptr with the real parser
/// *expr_ptr = expr;
/// ~~~
pub fn forward_ref<T: Copy Durable>(parser: @mut Parser<T>) -> Parser<T>
{
	|input: State| (*parser)(input)
}

/// or_v := e0 | e1 | â€¦
/// 
/// This is a version of or that is nicer to use when there are more than two alternatives.
pub fn or_v<T: Copy Durable>(parsers: @~[Parser<T>]) -> Parser<T>
{
	// A recursive algorithm would be a lot simpler, but it's not clear how that could
	// produce good error messages.
	assert !vec::is_empty(*parsers);
	
	|input: State|
	{
		let mut result: Option<Status<T>> = None;
		let mut errors = ~[];
		let mut max_index = uint::max_value;
		let mut i = 0u;
		while i < vec::len(*parsers) && option::is_none(&result)
		{
			match parsers[i](input)
			{
				result::Ok(ref pass) =>
				{
					result = option::Some(result::Ok(*pass));
				}
				result::Err(ref failure) =>
				{
					if failure.err_state.index > max_index || max_index == uint::max_value
					{
						errors = ~[failure.mesg];
						max_index = failure.err_state.index;
					}
					else if failure.err_state.index == max_index
					{
						vec::push(&mut errors, failure.mesg);
					}
				}
			}
			i += 1u;
		}
		
		if option::is_some(&result)
		{
			option::get(result)
		}
		else
		{
			let errs = do vec::filter(errors) |s| {!str::is_empty(**s)};
			let mesg = at_connect(errs, ~" or ");
			result::Err(Failed {old_state: input, err_state: State {index: max_index, ..input}, mesg: @mesg})
		}
	}
}

/// Returns a parser which always succeeds, but does not consume any input.
#[allow(deprecated_mode)]		// TODO: probably need to use &T instead
pub fn ret<T: Copy Durable>(value: T) -> Parser<T>
{
	|input: State| result::Ok(Succeeded {new_state: input, value: value})
}

/// seq2 := e0 e1
pub fn seq2<T0: Copy Durable, T1: Copy Durable, R: Copy Durable>
	(parser0: Parser<T0>, parser1: Parser<T1>, eval: fn@ (T0, T1) -> result::Result<R, @~str>) -> Parser<R>
{
	do parser0.thene() |a0| {
	do parser1.thene() |a1| {
		match eval(a0, a1)
		{
			result::Ok(ref value) =>
			{
				ret(*value)
			}
			result::Err(mesg) =>
			{
				fails(*mesg)
			}
		}
	}}
}

/// seq3 := e0 e1 e2
pub fn seq3<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, R: Copy Durable>
	(parser0: Parser<T0>, parser1: Parser<T1>, parser2: Parser<T2>, eval: fn@ (T0, T1, T2) -> result::Result<R, @~str>) -> Parser<R>
{
	do parser0.thene() |a0| {
	do parser1.thene() |a1| {
	do parser2.thene() |a2| {
		match eval(a0, a1, a2)
		{
			result::Ok(ref value) =>
			{
				ret(*value)
			}
			result::Err(mesg) =>
			{
				fails(*mesg)
			}
		}
	}}}
}

/// seq4 := e0 e1 e2 e3
pub fn seq4<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable, R: Copy Durable>
	(parser0: Parser<T0>, parser1: Parser<T1>, parser2: Parser<T2>, parser3: Parser<T3>, eval: fn@ (T0, T1, T2, T3) -> result::Result<R, @~str>) -> Parser<R>
{
	do parser0.thene() |a0| {
	do parser1.thene() |a1| {
	do parser2.thene() |a2| {
	do parser3.thene() |a3| {
		match eval(a0, a1, a2, a3)
		{
			result::Ok(ref value) =>
			{
				ret(*value)
			}
			result::Err(mesg) =>
			{
				fails(*mesg)
			}
		}
	}}}}
}

/// seq5 := e0 e1 e2 e3 e4
pub fn seq5<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable, T4: Copy Durable, R: Copy Durable>
	(parser0: Parser<T0>, parser1: Parser<T1>, parser2: Parser<T2>, parser3: Parser<T3>, parser4: Parser<T4>, eval: fn@ (T0, T1, T2, T3, T4) -> result::Result<R, @~str>) -> Parser<R>
{
	do parser0.thene() |a0| {
	do parser1.thene() |a1| {
	do parser2.thene() |a2| {
	do parser3.thene() |a3| {
	do parser4.thene() |a4| {
		match eval(a0, a1, a2, a3, a4)
		{
			result::Ok(ref value) =>
			{
				ret(*value)
			}
			result::Err(mesg) =>
			{
				fails(*mesg)
			}
		}
	}}}}}
}

/// seq6 := e0 e1 e2 e3 e4 e5
pub fn seq6<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable, T4: Copy Durable, T5: Copy Durable, R: Copy Durable>
	(parser0: Parser<T0>, parser1: Parser<T1>, parser2: Parser<T2>, parser3: Parser<T3>, parser4: Parser<T4>, parser5: Parser<T5>, eval: fn@ (T0, T1, T2, T3, T4, T5) -> result::Result<R, @~str>) -> Parser<R>
{
	do parser0.thene() |a0| {
	do parser1.thene() |a1| {
	do parser2.thene() |a2| {
	do parser3.thene() |a3| {
	do parser4.thene() |a4| {
	do parser5.thene() |a5| {
		match eval(a0, a1, a2, a3, a4, a5)
		{
			result::Ok(ref value) =>
			{
				ret(*value)
			}
			result::Err(mesg) =>
			{
				fails(*mesg)
			}
		}
	}}}}}}
}

/// seq7 := e0 e1 e2 e3 e4 e5 e6
pub fn seq7<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable, T4: Copy Durable, T5: Copy Durable, T6: Copy Durable, R: Copy Durable>
	(parser0: Parser<T0>, parser1: Parser<T1>, parser2: Parser<T2>, parser3: Parser<T3>, parser4: Parser<T4>, parser5: Parser<T5>, parser6: Parser<T6>, eval: fn@ (T0, T1, T2, T3, T4, T5, T6) -> result::Result<R, @~str>) -> Parser<R>
{
	do parser0.thene() |a0| {
	do parser1.thene() |a1| {
	do parser2.thene() |a2| {
	do parser3.thene() |a3| {
	do parser4.thene() |a4| {
	do parser5.thene() |a5| {
	do parser6.thene() |a6| {
		match eval(a0, a1, a2, a3, a4, a5, a6)
		{
			result::Ok(ref value) =>
			{
				ret(*value)
			}
			result::Err(mesg) =>
			{
				fails(*mesg)
			}
		}
	}}}}}}}
}

/// seq8 := e0 e1 e2 e3 e4 e5 e6 e7
pub fn seq8<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable, T4: Copy Durable, T5: Copy Durable, T6: Copy Durable, T7: Copy Durable, R: Copy Durable>
	(parser0: Parser<T0>, parser1: Parser<T1>, parser2: Parser<T2>, parser3: Parser<T3>, parser4: Parser<T4>, parser5: Parser<T5>, parser6: Parser<T6>, parser7: Parser<T7>, eval: fn@ (T0, T1, T2, T3, T4, T5, T6, T7) -> result::Result<R, @~str>) -> Parser<R>
{
	do parser0.thene() |a0| {
	do parser1.thene() |a1| {
	do parser2.thene() |a2| {
	do parser3.thene() |a3| {
	do parser4.thene() |a4| {
	do parser5.thene() |a5| {
	do parser6.thene() |a6| {
	do parser7.thene() |a7| {
		match eval(a0, a1, a2, a3, a4, a5, a6, a7)
		{
			result::Ok(ref value) =>
			{
				ret(*value)
			}
			result::Err(mesg) =>
			{
				fails(*mesg)
			}
		}
	}}}}}}}}
}

/// seq9 := e0 e1 e2 e3 e4 e5 e6 e7 e8
pub fn seq9<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable, T4: Copy Durable, T5: Copy Durable, T6: Copy Durable, T7: Copy Durable, T8: Copy Durable, R: Copy Durable>
	(parser0: Parser<T0>, parser1: Parser<T1>, parser2: Parser<T2>, parser3: Parser<T3>, parser4: Parser<T4>, parser5: Parser<T5>, parser6: Parser<T6>, parser7: Parser<T7>, parser8: Parser<T8>, eval: fn@ (T0, T1, T2, T3, T4, T5, T6, T7, T8) -> result::Result<R, @~str>) -> Parser<R>
{
	do parser0.thene() |a0| {
	do parser1.thene() |a1| {
	do parser2.thene() |a2| {
	do parser3.thene() |a3| {
	do parser4.thene() |a4| {
	do parser5.thene() |a5| {
	do parser6.thene() |a6| {
	do parser7.thene() |a7| {
	do parser8.thene() |a8| {
		match eval(a0, a1, a2, a3, a4, a5, a6, a7, a8)
		{
			result::Ok(ref value) =>
			{
				ret(*value)
			}
			result::Err(mesg) =>
			{
				fails(*mesg)
			}
		}
	}}}}}}}}}
}

/// seq2_ret0 := e0 e1
pub fn seq2_ret0<T0: Copy Durable, T1: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>) -> Parser<T0>
{
	seq2(p0, p1, |a0, _a1| result::Ok(a0))
}

/// seq2_ret1 := e0 e1
pub fn seq2_ret1<T0: Copy Durable, T1: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>) -> Parser<T1>
{
	seq2(p0, p1, |_a0, a1| result::Ok(a1))
}

/// seq3_ret0 := e0 e1 e2
pub fn seq3_ret0<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>) -> Parser<T0>
{
	seq3(p0, p1, p2, |a0, _a1, _a2| result::Ok(a0))
}

/// seq3_ret1 := e0 e1 e2
pub fn seq3_ret1<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>) -> Parser<T1>
{
	seq3(p0, p1, p2, |_a0, a1, _a2| result::Ok(a1))
}

/// seq3_ret2 := e0 e1 e2
pub fn seq3_ret2<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>) -> Parser<T2>
{
	seq3(p0, p1, p2, |_a0, _a1, a2| result::Ok(a2))
}

/// seq4_ret0 := e0 e1 e2 e3
pub fn seq4_ret0<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>, p3: Parser<T3>) -> Parser<T0>
{
	seq4(p0, p1, p2, p3, |a0, _a1, _a2, _a3| result::Ok(a0))
}

/// seq4_ret1 := e0 e1 e2 e3
pub fn seq4_ret1<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>, p3: Parser<T3>) -> Parser<T1>
{
	seq4(p0, p1, p2, p3, |_a0, a1, _a2, _a3| result::Ok(a1))
}

/// seq4_ret2 := e0 e1 e2 e3
pub fn seq4_ret2<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>, p3: Parser<T3>) -> Parser<T2>
{
	seq4(p0, p1, p2, p3, |_a0, _a1, a2, _a3| result::Ok(a2))
}

/// seq4_ret3 := e0 e1 e2 e3
pub fn seq4_ret3<T0: Copy Durable, T1: Copy Durable, T2: Copy Durable, T3: Copy Durable>(p0: Parser<T0>, p1: Parser<T1>, p2: Parser<T2>, p3: Parser<T3>) -> Parser<T3>
{
	seq4(p0, p1, p2, p3, |_a0, _a1, _a2, a3| result::Ok(a3))
}

// chain_suffix := (op e)*
#[doc(hidden)]
pub fn chain_suffix<T: Copy Durable, U: Copy Durable>(parser: Parser<T>, op: Parser<U>) -> Parser<@~[(U, T)]>
{
	let q = op.thene(
	|operator|
	{
		parser.thene(
		|value|
		{
			ret((operator, value))
		})
	});
	q.r0()
}

// When using tag it can be useful to use empty messages for interior parsers
// so we need to handle that case.
#[doc(hidden)]
pub fn or_mesg(mesg1: @~str, mesg2: @~str) -> @~str
{
	if !str::is_empty(*mesg1) && !str::is_empty(*mesg2)
	{
		@(*mesg1 + " or " + *mesg2)
	}
	else if !str::is_empty(*mesg1)
	{
		mesg1
	}
	else if !str::is_empty(*mesg2)
	{
		mesg2
	}
	else
	{
		@~""
	}
}

/// Parse methods which return a generic type.
pub trait GenericParsers
{
	/// Returns value if input matches s. Also see lit.
	fn litv<T: Copy Durable>(&self, value: T) -> Parser<T>;
}

/// Parse methods used to compose parsers.
///
/// Note that these don't actually consume input (although the parsers they are invoked with normally will).
pub trait Combinators<T: Copy Durable>
{
	/// chainl1 := e (op e)*
	/// 
	/// Left associative binary operator. eval is called for each parsed op.
	fn chainl1<U: Copy Durable>(&self, op: Parser<U>, eval: fn@ (T, U, T) -> T) -> Parser<T>;
	
	/// chainr1 := e (op e)*
	/// 
	/// Right associative binary operator. eval is called for each parsed op.
	fn chainr1<U: Copy Durable>(&self, op: Parser<U>, eval: fn@ (T, U, T) -> T) -> Parser<T>;
	
	/// Like note except that the mesg is also used for error reporting.
	/// 
	/// If label is not empty then it is used if the previous parser completely failed to parse or if its error
	/// message was empty. Otherwise it suppresses errors from the parser (in favor of a later err function).
	/// Non-empty labels should look like \"expression\" or \"statement\".
	fn err(&self, label: &str) -> Parser<T>;
	
	/// Parses the text and fails if all the text was not consumed. Leading space is allowed.
	/// 
	/// This is typically used in conjunction with the parse method. Note that space has to have the
	/// same type as parser which is backwards from how it is normally used.
	fn everything<U: Copy Durable>(&self, space: Parser<U>) -> Parser<T>;
	
	/// list := e (sep e)*
	/// 
	/// Values for each parsed e are returned.
	fn list<U: Copy Durable>(&self, sep: Parser<U>) -> Parser<@~[T]>;
	
	/// Logs the result of the previous parser.
	/// 
	/// If it was successful then the log is at INFO level. Otherwise it is at DEBUG level.
	/// Also see err method.
	fn note(&self, mesg: &str) -> Parser<T>;
	
	/// optional := e?
	fn optional(&self) -> Parser<Option<T>>;
	
	/// Returns a parser which first tries parser1, and if that fails, parser2.
	fn or(&self, parser2: Parser<T>) -> Parser<T>;
	
	/// Uses parser to parse text. Also see everything method.
	fn parse(&self, file: @~str, text: &str) -> ParseStatus<T>;
	
	/// Succeeds if parser matches input n to m times (inclusive).
	fn r(&self, n: uint, m: uint) -> Parser<@~[T]>;
	
	/// r0 := e*
	/// 
	/// Values for each parsed e are returned.
	fn r0(&self) -> Parser<@~[T]>;
	
	/// r1 := e+
	/// 
	/// Values for each parsed e are returned.
	fn r1(&self) -> Parser<@~[T]>;
	
	/// s0 := e [ \t\r\n]*
	fn s0(&self) -> Parser<T>;
	
	/// s1 := e [ \t\r\n]+
	fn s1(&self) -> Parser<T>;
	
	/// If parser1 is successful is successful then parser2 is called (and the value from parser1
	/// is ignored). If parser1 fails parser2 is not called.
	fn then<U: Copy Durable>(&self, parser2: Parser<U>) -> Parser<U>;
	
	/// If parser is successful then the function returned by eval is called
	/// with parser's result. If parser fails eval is not called.
	/// 
	/// Often used to translate parsed values: `p().thene({|pvalue| return(2*pvalue)})`
	fn thene<U: Copy Durable>(&self, eval: fn@ (T) -> Parser<U>) -> Parser<U>;
}

pub impl<T: Copy Durable> Parser<T> : Combinators<T>
{
	fn chainl1<U: Copy Durable>(&self, op: Parser<U>, eval: fn@ (T, U, T) -> T) -> Parser<T>
	{
		|input: State|
		{
			do result::chain((*self)(input))
			|pass|
			{
				match chain_suffix(self, op)(pass.new_state)
				{
					result::Ok(ref pass2) =>
					{
						let value = vec::foldl(pass.value, *pass2.value, |lhs: T, rhs: &(U, T)| {eval(lhs, rhs.first(), rhs.second())});
						result::Ok(Succeeded {new_state: pass2.new_state, value: value})
					}
					result::Err(ref failure) =>
					{
						result::Err(Failed {old_state: input, ..*failure})
					}
				}
			}
		}
	}
	
	fn chainr1<U: Copy Durable>(&self, op: Parser<U>, eval: fn@ (T, U, T) -> T) -> Parser<T>
	{
		|input: State|
		{
			do result::chain((*self)(input))
			|pass|
			{
				match chain_suffix(self, op)(pass.new_state)
				{
					result::Ok(ref pass2) =>
					{
						if !vec::is_empty(*pass2.value)
						{
							// e1 and [(op1 e2), (op2 e3)]
							let e1 = pass.value;
							let terms = pass2.value;
							
							// e1 and [op1, op2] and [e2, e3]
							let (ops, parsers) = vec::unzip(copy *terms);
							
							// [op1, op2] and [e1, e2] and e3
							let e3 = vec::last(parsers);
							let parsers = ~[e1] + vec::slice(parsers, 0u, vec::len(parsers) - 1u);
							
							// [(e1 op1), (e2 op2)] and e3
							let terms = vec::zip(parsers, ops);
							
							let value = vec::foldr(terms, e3, {|lhs: &(T, U), rhs| eval(lhs.first(), lhs.second(), rhs)});
							result::Ok(Succeeded {new_state: pass2.new_state, value: value})
						}
						else
						{
							result::Ok(Succeeded {new_state: pass2.new_state, value: pass.value})
						}
					}
					result::Err(ref failure) =>
					{
						result::Err(Failed {old_state: input ,.. *failure})
					}
				}
			}
		}
	}
	
	fn err(&self, label: &str) -> Parser<T>
	{
		let label = label.to_owned();
		
		|input: State|
		{
			do result::chain_err((self.note(label))(input))
			|failure| 
			{
				if str::is_empty(label)
				{
					result::Err(Failed {mesg: @~"", ..failure})
				}
				else if failure.err_state.index == input.index || str::is_empty(*failure.mesg)
				{
					result::Err(Failed {mesg: @copy label, ..failure})
				}
				else
				{
					// If we managed to parse something then it is usually better to
					// use that error message. (If that's not what you want then use
					// empty strings there).
					result::Err(failure)
				}
			}
		}
	}
	
	fn everything<U: Copy Durable>(&self, space: Parser<U>) -> Parser<T>
	{
		seq3_ret1(space, self, eot())
	}
	
	fn list<U: Copy Durable>(&self, sep: Parser<U>) -> Parser<@~[T]>
	{
		let term = sep.then(self).r0();
		
		|input: State|
		{
			do result::chain((*self)(input))
			|pass|
			{
				match term(pass.new_state)
				{
					result::Ok(ref pass2) =>
					{
						result::Ok(Succeeded {value: @(~[pass.value] + *pass2.value), ..*pass2})
					}
					result::Err(ref failure) =>
					{
						result::Err(Failed {old_state: input, ..*failure})
					}
				}
			}
		}
	}
	
	fn note(&self, mesg: &str) -> Parser<T>
	{
		let mesg = mesg.to_owned();
		
		|input: State|
		{
			match (*self)(input)
			{
				result::Ok(ref pass) =>
				{
					// Note that we make multiple calls to munge_chars which is fairly slow, but
					// we only do that when actually logging: when info or debug logging is off
					// the munge_chars calls aren't evaluated.
					assert pass.new_state.index >= input.index;			// can't go backwards on success (but no progress is fine, eg e*)
					if pass.new_state.index > input.index
					{
						info!("%s", munge_chars(input.text));
						info!("%s^ %s parsed '%s'", repeat_char(' ', pass.new_state.index), mesg, str::slice(munge_chars(input.text), input.index, pass.new_state.index));
					}
					else
					{
						info!("%s", munge_chars(input.text));
						info!("%s^ %s passed", repeat_char(' ', pass.new_state.index), mesg);
					}
					result::Ok(*pass)
				}
				result::Err(ref failure) =>
				{
					assert failure.old_state.index == input.index;			// on errors the next parser must begin at the start
					assert failure.err_state.index >= input.index;			// errors can't be before the input
					
					debug!("%s", munge_chars(input.text));
					if failure.err_state.index > input.index 
					{
						debug!("%s^%s! %s failed", repeat_char('-', input.index), repeat_char(' ', failure.err_state.index - input.index), mesg);
					}
					else
					{
						debug!("%s^ %s failed", repeat_char('-', input.index), mesg);
					}
					result::Err(*failure)
				}
			}
		}
	}
	
	fn optional(&self) -> Parser<Option<T>>
	{
		|input: State|
		{
			match (*self)(input)
			{
				result::Ok(ref pass) =>
				{
					result::Ok(Succeeded {new_state: pass.new_state, value: option::Some(pass.value)})
				}
				result::Err(ref _failure) =>
				{
					result::Ok(Succeeded {new_state: input, value: option::None})
				}
			}
		}
	}
	
	fn or(&self, parser2: Parser<T>) -> Parser<T>
	{
		|input: State|
		{
			do result::chain_err((*self)(input))
			|failure1|
			{
				do result::chain_err(parser2(input))
				|failure2|
				{
					if failure1.err_state.index > failure2.err_state.index
					{
						result::Err(failure1)
					}
					else if failure1.err_state.index < failure2.err_state.index
					{
						result::Err(failure2)
					}
					else
					{
						result::Err(Failed {mesg: or_mesg(failure1.mesg, failure2.mesg), ..failure2})
					}
				}
			}
		}
	}
	
	fn parse(&self, file: @~str, text: &str) -> ParseStatus<T>
	{
		let chars = chars_with_eot(text);
		let input = State {file: file, text: chars, index: 0u, line: 1};
		match (*self)(input)
		{
			result::Ok(ref pass) =>
			{
				result::Ok(pass.value)
			}
			result::Err(ref failure) =>
			{
				let col = get_col(chars, failure.err_state.index);
				result::Err(ParseFailed {file: failure.old_state.file, line: failure.err_state.line as uint, col: col, mesg: failure.mesg})
			}
		}
	}
	
	fn r(&self, n: uint, m: uint) -> Parser<@~[T]>
	{
		|input: State|
		{
			let mut output = input;
			let mut values = ~[];
			loop
			{
				match (*self)(output)
				{
					result::Ok(ref pass) =>
					{
						assert pass.new_state.index > output.index;	// must make progress to ensure loop termination
						output = pass.new_state;
						vec::push(&mut values, pass.value);
					}
					result::Err(_) =>
					{
						break;
					}
				}
			}
			
			let count = vec::len(values);
			if n <= count && count <= m
			{
				result::Ok(Succeeded {new_state: output, value: @values})
			}
			else
			{
				result::Err(Failed {old_state: input, err_state: output, mesg: @~""})
			}
		}
	}
	
	fn r0(&self) -> Parser<@~[T]>
	{
		self.r(0u, uint::max_value)
	}
	
	fn r1(&self) -> Parser<@~[T]>
	{
		self.r(1u, uint::max_value)
	}
	
	fn s0(&self) -> Parser<T>
	{
		// It would be simpler to write this with scan0, but scan0 is relatively inefficient
		// and s0 is typically called a lot.
		|input: State|
		{
			do result::chain((*self)(input))
			|pass|
			{
				let mut i = pass.new_state.index;
				let mut line = pass.new_state.line;
				loop
				{
					if input.text[i] == '\r' && input.text[i+1u] == '\n'
					{
						line += 1;
						i += 1u;
					}
					else if input.text[i] == '\n'
					{
						line += 1;
					}
					else if input.text[i] == '\r'
					{
						line += 1;
					}
					else if input.text[i] != ' ' && input.text[i] != '\t'
					{
						break;
					}
					i += 1u;
				}
				
				result::Ok(Succeeded {new_state: State {index: i, line: line, ..pass.new_state}, value: pass.value})
			}
		}
	}
	
	fn s1(&self) -> Parser<T>
	{
		|input: State|
		{
			do result::chain(self.s0()(input))
			|pass|
			{
				if option::is_some(&str::find_char(" \t\r\n", input.text[pass.new_state.index - 1u]))	// little cheesy, but saves us from adding a helper fn
				{
					result::Ok(pass)
				}
				else
				{
					result::Err(Failed {old_state: input, err_state: pass.new_state, mesg: @~"whitespace"})
				}
			}
		}
	}
	
	fn then<U: Copy Durable>(&self, parser2: Parser<U>) -> Parser<U>
	{
		|input: State|
		{
			do result::chain((*self)(input))
			|pass|
			{
				do result::chain_err(parser2(pass.new_state))
					|failure| {result::Err(Failed {old_state: input, ..failure})}
			}
		}
	}
	
	fn thene<U: Copy Durable>(&self, eval: fn@ (T) -> Parser<U>) -> Parser<U>
	{
		|input: State|
		{
			do result::chain((*self)(input))
			|pass|
			{
				do result::chain_err(eval(pass.value)(pass.new_state))
					|failure| {result::Err(Failed {old_state: input, ..failure})}
			}
		}
	}
}

impl &str : GenericParsers
{
	fn litv<T: Copy Durable>(&self, value: T) -> Parser<T>
	{
		let s = self.to_owned();
		
		|input: State|
		{
			match s.lit()(input)
			{
				result::Ok(ref pass) =>
				{
					result::Ok(Succeeded {new_state: pass.new_state, value: value})
				}
				result::Err(ref failure) =>
				{
					result::Err(*failure)
				}
			}
		}
	}
}